# OS (Operating System)

## 1. 프로세스 & 스레드
### _1) 프로세스_
> : 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램
* 메모리에 올라와 실행되고 있는 프로그램의 인스턴스 (독립적인 개체)
* 운영체제로부터 시스템 자원을 할당받는 작업의 단위

#### [할당받는 시스템 자원의 예]
* CPU 시간
* 운영되기 위해 필요한 주소 공간
* Code, Data, Stack, Heap의 구조로 되어 있는 독립된 메모리 영역

![process](https://github.com/WeareSoft/tech-interview/raw/master/contents/images/process.png "process")

#### [특징]
* 프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap의 구조)을 할당받는다.
* 기본적으로 프로세스당 최소 1개의 스레드(메인 스레드)를 가지고 있다.
* 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.
* 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC, inter-process communication)을 사용해야 한다.
  * 파이프, 파일, 소켓 등을 이용한 통신 방법 이용
  
### _2) 스레드_
> : 프로세스 내에서 실행되는 여러 흐름의 단위
* 프로세스의 특정한 수행 경로
* 프로세스가 할당받은 자원을 이용하는 실행의 단위

![thread](https://github.com/WeareSoft/tech-interview/raw/master/contents/images/thread.png "thread")

#### [특징]
* 스레드는 프로세스 내에서 각각 Stack만 따로 할당받고 Code, Data, Heap 영역은 공유한다.
* 각각의 스레드는 별도의 레지스터와 스택을 갖고 있지만, 힙 메모리는 서로 읽고 쓸 수 있다.
* 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드(sibling thread)도 그 변경 결과를 즉시 볼 수 있다.

### _3) 멀티 프로세스 대신 멀티 스레드를 사용하는 이유_
> : 프로그램을 여러 개 키는 것보다 하나의 프로그램 안에서 여러 작업을 해결하는 것이 효율적
* 자원의 효율성 증대
  * 멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.
  * 스레드는 프로세스 내의 메모리를 공유하기 때문에 독립적인 프로세스와 달리 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어들게 된다.
* 처리 비용 감소 및 응답 시간 단축
  * 프로세스 간의 통신(IPC)보다 스레드 간의 통신의 비용이 적으므로 작업들 간의 통신의 부담이 줄어든다.
  * 프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠르다.

![multi](https://github.com/WeareSoft/tech-interview/raw/master/contents/images/multi-thread.png "multi thread")

## 2. 교착상태

### _1) 교착상태 (Deadlock)_
* 첫 번째 스레드는 두 번째 스레드가 들고 있는 객체의 락이 풀리기를 기다리고 있고, 두 번째 스레드 역시 첫 번째 스레드가 들고 있는 객체의 락이 풀리기를 기다리는 상황을 일컷는다.
* 모든 스레드가 락이 풀리기를 기다리고 있기 때문에, 무한 대기 상태에 빠지게 된다. 이런 스레드를 교착상태에 빠졌다고 한다.

#### [조건]
* 상호 배제(mutual exclusion)
  * 한 번에 한 프로세스만 공유 자원을 사용할 수 있다.
  * 좀 더 정확하게는, 공유 자원에 대한 접근 권한이 제한된다. 자원의 양이 제한되어 있더라도 교착상태는 발생할 수 있다.
* 들고 기다리기(hold and wait) = 점유대기
  * 공유 자원에 대한 접근 권한을 갖고 있는 프로세스가, 그 접근 권한을 양보하지 않은 상태에서 다른 자원에 대한 접근 권한을 요구할 수 있다.
* 선취(preemption) 불가능 = 비선점
  * 한 프로세스가 다른 프로세스의 자원 접근 권한을 강제로 취소할 수 없다.
* 대기 상태의 사이클(circular wait) = 순환대기
  * 두 개 이상의 프로세스가 자원 접근을 기다리는데, 그 관계에 사이클이 존재한다.
 
#### [방지 방법]
* 4가지 조건들 가운데 하나를 제거하면 된다.
* 공유 자원 중 많은 경우가 한 번에 한 프로세스만 사용할 수 있기 때문에(예를 들어, 프린트) 1번 조건은 제거하기 어렵다.
* 대부분의 교착상태 방지 알고리즘은 4번 조건, 즉 대기 상태의 사이클이 발생하는 일을 막는 데 초점이 맞춰져 있다.

## 3. Context Switching

### _1) Context Switching_
> : 현재 진행하고 있는 Task(Process, Thread)의 상태를 저장하고 다음 진행할 Task의 상태 값을 읽어 적용하는 과정을 말한다.

#### [과정]
1. Task의 대부분 정보는 Register에 저장되고 PCB(Process Control Block)로 관리된다.
1. 현재 실행하고 있는 Task의 PCB 정보를 저장한다. (Process Stack, Ready Queue)
1. 다음 실행할 Task의 PCB 정보를 읽어 Register에 적재하고 CPU가 이전에 진행했던 과정을 연속적으로 수행할 수 있다.

#### [비용 비교]
* Process Context Switching 비용 > Thread Context Switching 비용
* Thread는 Stack 영역을 제외한 모든 메모리를 공유하므로 Context Switching 수행 시 Stack 영역만 변경하면 되기 때문에 비용이 적게 든다.


---
## _* 참고_
1. <https://github.com/WeareSoft/tech-interview/blob/master/contents/os.md#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%A0%84%EB%9E%B5>
